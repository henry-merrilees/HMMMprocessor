$version Generated by VerilatedVcd $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire  1 V clk $end
  $var wire  1 W reset $end
  $scope module hmmm $end
   $var wire  1 , ALUSrcA $end
   $var wire  2 ' ALUSrcB [1:0] $end
   $var wire 16 # Instr [15:0] $end
   $var wire  2 & MemAdrSrc [1:0] $end
   $var wire  1 + MemDataSrc $end
   $var wire  1 ( MemWrite $end
   $var wire  2 % PcSrc [1:0] $end
   $var wire  2 $ RegSrcX [1:0] $end
   $var wire  1 ) RegWriteX $end
   $var wire  1 * RegWriteY $end
   $var wire 32 - alu_op [31:0] $end
   $var wire  1 V clk $end
   $var wire 32 . instruction_type [31:0] $end
   $var wire  1 W reset $end
   $scope module controller $end
    $var wire  1 , ALUSrcA $end
    $var wire  2 ' ALUSrcB [1:0] $end
    $var wire  2 & MemAdrSrc [1:0] $end
    $var wire  1 + MemDataSrc $end
    $var wire  1 ( MemWrite $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  2 $ RegSrcX [1:0] $end
    $var wire  1 ) RegWriteX $end
    $var wire  1 * RegWriteY $end
    $var wire 32 - alu_op [31:0] $end
    $var wire 16 # instr [15:0] $end
    $var wire 32 . instruction_type [31:0] $end
   $upscope $end
   $scope module datapath $end
    $var wire  1 , ALUSrcA $end
    $var wire  2 ' ALUSrcB [1:0] $end
    $var wire  8 2 Imm [7:0] $end
    $var wire 16 # Instr [15:0] $end
    $var wire  2 & MemAdrSrc [1:0] $end
    $var wire  1 + MemDataSrc $end
    $var wire  1 ( MemWrite $end
    $var wire  8 / Pc [7:0] $end
    $var wire  8 X PcNext [7:0] $end
    $var wire  8 0 PcPlus2 [7:0] $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  8 1 PcTarget [7:0] $end
    $var wire  2 $ RegSrcX [1:0] $end
    $var wire  1 ) RegWriteX $end
    $var wire  1 * RegWriteY $end
    $var wire 32 - alu_op [31:0] $end
    $var wire 16 4 alu_result [15:0] $end
    $var wire 16 5 alu_src_a [15:0] $end
    $var wire 16 6 alu_src_b [15:0] $end
    $var wire  1 V clk $end
    $var wire 16 C imm_ext [15:0] $end
    $var wire 32 . instruction_type [31:0] $end
    $var wire  8 3 mem_data_address [7:0] $end
    $var wire 16 ; mem_read_data [15:0] $end
    $var wire 16 < mem_write_data [15:0] $end
    $var wire  4 = rX [3:0] $end
    $var wire  4 > rY [3:0] $end
    $var wire  4 ? rZ [3:0] $end
    $var wire  1 W reset $end
    $var wire 16 Y result [15:0] $end
    $var wire 16 7 rf_read_data_1 [15:0] $end
    $var wire 16 8 rf_read_data_2 [15:0] $end
    $var wire 16 9 rf_read_data_3 [15:0] $end
    $var wire 16 : rf_write_data_1 [15:0] $end
    $var wire 16 4 rf_write_data_2 [15:0] $end
    $var wire  1 A sign $end
    $var wire  1 B take_jump $end
    $var wire  1 @ zero $end
    $scope module alu $end
     $var wire 32 - alu_op [31:0] $end
     $var wire 16 4 alu_result [15:0] $end
     $var wire  1 A sign $end
     $var wire 16 5 src_a [15:0] $end
     $var wire 16 6 src_b [15:0] $end
     $var wire  1 @ zero $end
    $upscope $end
    $scope module mem $end
     $var wire  1 V clk $end
     $var wire  8 3 data_address [7:0] $end
     $var wire  8 / instruction_address [7:0] $end
     $var wire 16 # instruction_data [15:0] $end
     $var wire 16 ; read_data [15:0] $end
     $var wire 16 < write_data [15:0] $end
     $var wire  1 ( write_en $end
    $upscope $end
    $scope module rf $end
     $var wire  4 = address_1 [3:0] $end
     $var wire  4 > address_2 [3:0] $end
     $var wire  4 ? address_3 [3:0] $end
     $var wire  1 V clk $end
     $var wire 16 7 read_data_1 [15:0] $end
     $var wire 16 8 read_data_2 [15:0] $end
     $var wire 16 9 read_data_3 [15:0] $end
     $var wire 16 D registers[0] [15:0] $end
     $var wire 16 N registers[10] [15:0] $end
     $var wire 16 O registers[11] [15:0] $end
     $var wire 16 P registers[12] [15:0] $end
     $var wire 16 Q registers[13] [15:0] $end
     $var wire 16 R registers[14] [15:0] $end
     $var wire 16 S registers[15] [15:0] $end
     $var wire 16 E registers[1] [15:0] $end
     $var wire 16 F registers[2] [15:0] $end
     $var wire 16 G registers[3] [15:0] $end
     $var wire 16 H registers[4] [15:0] $end
     $var wire 16 I registers[5] [15:0] $end
     $var wire 16 J registers[6] [15:0] $end
     $var wire 16 K registers[7] [15:0] $end
     $var wire 16 L registers[8] [15:0] $end
     $var wire 16 M registers[9] [15:0] $end
     $var wire 16 : write_data_1 [15:0] $end
     $var wire 16 4 write_data_2 [15:0] $end
     $var wire  1 ) write_en_1 $end
     $var wire  1 * write_en_2 $end
    $upscope $end
    $scope module unnamedblk1 $end
     $var wire 32 T i [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 U i [31:0] $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b0001000100000001 #
b00 $
b00 %
b00 &
b00 '
0(
1)
0*
0+
0,
b00000000000000000000000000000000 -
b00000000000000000000000000000100 .
b00000000 /
b00000010 0
b00000010 1
b00000001 2
b00000001 3
b0000000000000000 4
b0000000000000000 5
b0000000000000000 6
b0000000000000000 7
b0000000000000000 8
b0000000000000000 9
b0000000000000001 :
b0001001000000010 ;
b0000000000000000 <
b0001 =
b0000 >
b0001 ?
1@
0A
1B
b0000000000000001 C
b0000000000000000 D
b0000000000000000 E
b0000000000000000 F
b0000000000000000 G
b0000000000000000 H
b0000000000000000 I
b0000000000000000 J
b0000000000000000 K
b0000000000000000 L
b0000000000000000 M
b0000000000000000 N
b0000000000000000 O
b0000000000000000 P
b0000000000000000 Q
b0000000000000000 R
b0000000000000000 S
b00000000000000000000000000000000 T
b00000000000000000000000000000000 U
1V
1W
b00000000 X
b0000000000000000 Y
#1
0V
#2
b0001001000000010 #
b00000010 /
b00000100 0
b00000100 1
b00000010 2
b00000010 3
b0000000000000010 :
b0001001100000011 ;
b0010 =
b0010 ?
b0000000000000010 C
b0000000000000001 E
1V
0W
b00000100 X
#3
0V
#4
b0001001100000011 #
b00000100 /
b00000110 0
b00000110 1
b00000011 2
b00000011 3
b0000000000000011 :
b0001010100101000 ;
b0011 =
b0011 ?
b0000000000000011 C
b0000000000000010 F
1V
b00000110 X
#5
0V
#6
b0001010100101000 #
b00000110 /
b00001000 0
b01010000 1
b00101000 2
b00101000 3
b0000000000000010 4
b0000000000000010 5
b0000000000000010 8
b0000000000101000 :
b0000000000000000 ;
b0000000000000010 <
b0101 =
b0010 >
b1000 ?
0@
b0000000000101000 C
b0000000000000011 G
1V
b00001000 X
#7
0V
#8
b1011010000001001 #
b10 $
b10 %
b00000000000000000000000000011001 .
b00001000 /
b00001010 0
b00010010 1
b00001001 2
b00001001 3
b0000000000000000 4
b0000000000000000 5
b0000000000000000 8
b0000000000001010 :
b0100000101010011 ;
b0000000000000000 <
b0100 =
b0000 >
b1001 ?
1@
b0000000000001001 C
b0000000000101000 I
1V
b00010010 X
#9
0V
#10
b0100000101010011 #
b00 $
b00 %
b01 &
b11 '
1(
0)
1*
1+
b00000000000000000000000000001000 .
b00010010 /
b00010100 0
b10100110 1
b01010011 2
b00101000 3
b0000000000101001 4
b0000000000101000 5
b0000000000000001 6
b0000000000000001 7
b0000000000101000 8
b0000000000000011 9
b0000000001010011 :
b0000000000000000 ;
b0000000000000001 <
b0001 =
b0101 >
b0011 ?
0@
b0000000001010011 C
b0000000000001010 H
1V
b00010100 X
#11
0V
#12
b0100001001010011 #
b00010100 /
b00010110 0
b00101001 3
b0000000000101010 4
b0000000000101001 5
b0000000000000010 7
b0000000000101001 8
b0000000000000010 <
b0010 =
b0000000000101001 I
1V
b00010110 X
#13
0V
#14
b0100001101010011 #
b00010110 /
b00011000 0
b00101010 3
b0000000000101011 4
b0000000000101010 5
b0000000000000011 7
b0000000000101010 8
b0000000000000011 <
b0011 =
b0000000000101010 I
1V
b00011000 X
#15
0V
#16
b0101000100101010 #
b11 $
b00 &
b01 '
0(
1)
0+
1,
b00000000000000000000000000001011 .
b00011000 /
b00011010 0
b01010100 1
b00101010 2
b0000000000000001 5
b0000000000101010 6
b0000000000000001 7
b0000000000000010 8
b0000000000000000 9
b0000000000101011 :
b0000000000000011 ;
b0000000000101011 <
b0001 =
b0010 >
b1010 ?
b0000000000101010 C
b0000000000101011 I
1V
b00011010 X
#17
0V
#18
b0101001000101010 #
b00011010 /
b00011100 0
b0000000001010101 4
b0000000000101011 5
b0000000000101011 7
b0000000000101011 8
b0000000001010101 :
b0000000001010101 <
b0010 =
b0000000000101011 E
b0000000000101011 F
1V
b00011100 X
#19
0V
#20
b0101001100101010 #
b00011100 /
b00011110 0
b0000000000101101 4
b0000000000000011 5
b0000000000000011 7
b0000000001010101 8
b0000000000101101 :
b0000000000101101 <
b0011 =
b0000000001010101 F
1V
b00011110 X
#21
0V
#22
b0100001101010010 #
b01 $
b10 &
b11 '
0,
b00000000000000000000000000000001 -
b00000000000000000000000000000111 .
b00011110 /
b00100000 0
b10100100 1
b01010010 2
b0000000000101010 4
b0000000000101011 5
b0000000000000001 6
b0000000000101101 7
b0000000000101011 8
b0000000000101101 9
b0000000000000011 :
b0000000000101010 <
b0101 >
b0010 ?
b0000000001010010 C
b0000000000101101 F
b0000000000101101 G
1V
b00100000 X
#23
0V
#24
b0100001001010010 #
b00100000 /
b00100010 0
b00101001 3
b0000000000101001 4
b0000000000101010 5
b0000000000101010 8
b0000000000000010 :
b0000000000000010 ;
b0000000000101001 <
b0010 =
b0000000000000011 G
b0000000000101010 I
1V
b00100010 X
#25
0V
#26
b0100000101010010 #
b00100010 /
b00100100 0
b00101000 3
b0000000000101000 4
b0000000000101001 5
b0000000000101011 7
b0000000000101001 8
b0000000000000010 9
b0000000000000001 :
b0000000000000001 ;
b0000000000101000 <
b0001 =
b0000000000000010 F
b0000000000101001 I
1V
b00100100 X
#27
0V
#28
b0000010000000011 #
b00 $
b11 %
b00 &
b00 '
0)
b00000000000000000000000000000000 -
b00000000000000000000000000010011 .
b00100100 /
b00100110 0
b00001010 1
b00000011 2
b00000011 3
b0000000000000011 4
b0000000000000000 5
b0000000000000011 6
b0000000000001010 7
b0000000000000000 8
b0000000000000011 9
b0000000000000011 :
b0001010100101000 ;
b0000000000000011 <
b0100 =
b0000 >
b0011 ?
b0000000000000011 C
b0000000000000001 E
b0000000000101000 I
1V
b00001010 X
#29
0V
#30
b0000000100000010 #
b00 %
b00000000000000000000000000000011 .
b00001010 /
b00001100 0
b00000100 1
b00000010 2
b00000010 3
b0000000000000010 4
b0000000000000010 6
b0000000000000001 7
b0000000000000010 9
b0000000000000010 :
b0001001100000011 ;
b0000000000000010 <
b0001 =
b0010 ?
b0000000000000010 C
b0000000000000011 D
1V
b00001100 X
#31
0V
#32
b0000001000000010 #
b00001100 /
b00001110 0
b0000000000000010 7
b0010 =
b0000000000000010 D
1V
b00001110 X
#33
0V
#34
b0000001100000010 #
b00001110 /
b00010000 0
b0000000000000011 7
b0011 =
1V
b00010000 X
#35
0V
#36
b0000000000000000 #
b00000000000000000000000000000000 .
b00010000 /
b00010010 0
b00000000 1
b00000000 2
b00000000 3
b0000000000000000 4
b0000000000000000 6
b0000000000000000 7
b0000000000000000 9
b0000000000000000 :
b0001000100000001 ;
b0000000000000000 <
b0000 =
b0000 ?
1@
b0000000000000000 C
1V
b00010010 X
#37
0V
#38
b0100000101010011 #
b01 &
b11 '
1(
1+
b00000000000000000000000000001000 .
b00010010 /
b00010100 0
b10100110 1
b01010011 2
b00101000 3
b0000000000101001 4
b0000000000101000 5
b0000000000000001 6
b0000000000000001 7
b0000000000101000 8
b0000000000000011 9
b0000000001010011 :
b0000000000000001 ;
b0000000000000001 <
b0001 =
b0101 >
b0011 ?
0@
b0000000001010011 C
b0000000000000000 D
b00000000000000000000000000001111 T
b00000000000000000000000011111111 U
1V
b00010100 X
