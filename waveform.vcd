$version Generated by VerilatedVcd $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire  1 L clk $end
  $var wire  1 M reset $end
  $scope module hmmm $end
   $var wire 16 # Instr [15:0] $end
   $var wire  1 ( MemAdrSrc $end
   $var wire  1 ) MemDataSrc $end
   $var wire  1 & MemWrite $end
   $var wire  2 % PcSrc [1:0] $end
   $var wire  2 $ RegSrc [1:0] $end
   $var wire  1 ' RegWrite $end
   $var wire 32 * aluop [31:0] $end
   $var wire  1 L clk $end
   $var wire 32 + instruction_type [31:0] $end
   $var wire  1 M reset $end
   $scope module controller $end
    $var wire  1 ( MemAdrSrc $end
    $var wire  1 ) MemDataSrc $end
    $var wire  1 & MemWrite $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  2 $ RegSrc [1:0] $end
    $var wire  1 ' RegWrite $end
    $var wire 32 * aluop [31:0] $end
    $var wire 16 # instr [15:0] $end
    $var wire 32 + instruction_type [31:0] $end
   $upscope $end
   $scope module datapath $end
    $var wire 16 O ALUResult [15:0] $end
    $var wire  8 / Imm [7:0] $end
    $var wire 16 # Instr [15:0] $end
    $var wire  1 ( MemAdrSrc $end
    $var wire  8 0 MemDataAddress [7:0] $end
    $var wire  1 ) MemDataSrc $end
    $var wire  1 & MemWrite $end
    $var wire  8 , Pc [7:0] $end
    $var wire  8 N PcNext [7:0] $end
    $var wire  8 - PcPlus2 [7:0] $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  8 . PcTarget [7:0] $end
    $var wire  2 $ RegSrc [1:0] $end
    $var wire  1 ' RegWrite $end
    $var wire 16 1 Result [15:0] $end
    $var wire 16 P SrcA [15:0] $end
    $var wire  1 L clk $end
    $var wire 32 + instruction_type [31:0] $end
    $var wire 16 5 mem_read_data [15:0] $end
    $var wire 16 6 mem_write_data [15:0] $end
    $var wire  4 7 rX [3:0] $end
    $var wire  4 8 rY [3:0] $end
    $var wire  4 9 rZ [3:0] $end
    $var wire  1 M reset $end
    $var wire 16 2 rf_read_data_1 [15:0] $end
    $var wire 16 3 rf_read_data_2 [15:0] $end
    $var wire 16 4 rf_read_data_3 [15:0] $end
    $scope module mem $end
     $var wire  1 L clk $end
     $var wire  8 0 data_address [7:0] $end
     $var wire  8 , instruction_address [7:0] $end
     $var wire 16 # instruction_data [15:0] $end
     $var wire 16 5 read_data [15:0] $end
     $var wire 16 6 write_data [15:0] $end
     $var wire  1 & write_en $end
    $upscope $end
    $scope module rf $end
     $var wire  4 7 address_1 [3:0] $end
     $var wire  4 8 address_2 [3:0] $end
     $var wire  4 9 address_3 [3:0] $end
     $var wire  1 L clk $end
     $var wire 16 2 read_data_1 [15:0] $end
     $var wire 16 3 read_data_2 [15:0] $end
     $var wire 16 4 read_data_3 [15:0] $end
     $var wire 16 : registers[0] [15:0] $end
     $var wire 16 D registers[10] [15:0] $end
     $var wire 16 E registers[11] [15:0] $end
     $var wire 16 F registers[12] [15:0] $end
     $var wire 16 G registers[13] [15:0] $end
     $var wire 16 H registers[14] [15:0] $end
     $var wire 16 I registers[15] [15:0] $end
     $var wire 16 ; registers[1] [15:0] $end
     $var wire 16 < registers[2] [15:0] $end
     $var wire 16 = registers[3] [15:0] $end
     $var wire 16 > registers[4] [15:0] $end
     $var wire 16 ? registers[5] [15:0] $end
     $var wire 16 @ registers[6] [15:0] $end
     $var wire 16 A registers[7] [15:0] $end
     $var wire 16 B registers[8] [15:0] $end
     $var wire 16 C registers[9] [15:0] $end
     $var wire 16 1 write_data_1 [15:0] $end
     $var wire  1 ' write_en_1 $end
    $upscope $end
    $scope module unnamedblk1 $end
     $var wire 32 J i [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 K i [31:0] $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b0001000100101010 #
b00 $
b00 %
0&
1'
1(
0)
b00000000000000000000000000000000 *
b00000000000000000000000000000100 +
b00000000 ,
b00000010 -
b01010100 .
b00101010 /
b00000000 0
b0000000000101010 1
b0000000000000000 2
b0000000000000000 3
b0000000000000000 4
b0001000100101010 5
b0000000000000000 6
b0001 7
b0010 8
b1010 9
b0000000000000000 :
b0000000000000000 ;
b0000000000000000 <
b0000000000000000 =
b0000000000000000 >
b0000000000000000 ?
b0000000000000000 @
b0000000000000000 A
b0000000000000000 B
b0000000000000000 C
b0000000000000000 D
b0000000000000000 E
b0000000000000000 F
b0000000000000000 G
b0000000000000000 H
b0000000000000000 I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
1L
1M
b00000000 N
b0000000000000000 O
b0000000000000000 P
#1
0L
#2
b0011000101100100 #
1&
0'
0(
1)
b00000000000000000000000000001010 +
b00000010 ,
b00000100 -
b11001000 .
b01100100 /
b01100100 0
b0000000001100100 1
b0000000000101010 2
b0000000000000000 5
b0000000000101010 6
b0110 8
b0100 9
b0000000000101010 ;
1L
0M
b00000100 N
#3
0L
#4
b0100000100010001 #
1(
b00000000000000000000000000000110 +
b00000100 ,
b00000110 -
b00100010 .
b00010001 /
b00101010 0
b0000000000010001 1
b0000000000101010 3
b0000000000101010 4
b0001 8
b0001 9
1L
b00000110 N
#5
0L
#6
b0001001000000110 #
0&
1'
0)
b00000000000000000000000000000100 +
b00000110 ,
b00001000 -
b00001100 .
b00000110 /
b00000000 0
b0000000000000110 1
b0000000000000000 2
b0000000000000000 3
b0000000000000000 4
b0001000100101010 5
b0000000000000000 6
b0010 7
b0000 8
b0110 9
1L
b00001000 N
#7
0L
#8
b0000001000000011 #
b11 %
0'
0(
b00000000000000000000000000010011 +
b00001000 ,
b00001010 -
b00000011 /
b00000011 0
b0000000000000011 1
b0000000000000110 2
b0001001000000110 5
b0011 9
b0000000000000110 <
1L
b00001100 N
#9
0L
#10
b1011000000001000 #
b10 %
b00000000000000000000000000010100 +
b00001100 ,
b00001110 -
b00010000 .
b00001000 /
b00001000 0
b0000000000001000 1
b0000000000000000 2
b0000000000000010 5
b0000 7
b1000 9
1L
b00010000 N
#11
0L
#12
b0000000000000010 #
b00 %
1(
b00000000000000000000000000000011 +
b00010000 ,
b00010010 -
b00000100 .
b00000010 /
b00000000 0
b0000000000000010 1
b0000000000000110 4
b0001000100101010 5
b0010 9
1L
b00010010 N
#13
0L
#14
b0010001101100100 #
b01 $
1'
0(
b00000000000000000000000000001001 +
b00010010 ,
b00010100 -
b11001000 .
b01100100 /
b01100100 0
b0000000000101010 1
b0000000000000000 4
b0000000000101010 5
b0011 7
b0110 8
b0100 9
1L
b00010100 N
#15
0L
#16
b0100010000010000 #
1(
b00000000000000000000000000000101 +
b00010100 ,
b00010110 -
b00100000 .
b00010000 /
b00101010 0
b0000000000101010 3
b0100 7
b0001 8
b0000 9
b0000000000101010 =
1L
b00010110 N
#17
0L
#18
b0000001100000010 #
b00 $
0'
b00000000000000000000000000000011 +
b00010110 ,
b00011000 -
b00000100 .
b00000010 /
b00000000 0
b0000000000000010 1
b0000000000101010 2
b0000000000000000 3
b0000000000000110 4
b0001000100101010 5
b0011 7
b0000 8
b0010 9
b0000000000101010 >
1L
b00011000 N
#19
0L
#20
b0000010000000010 #
b00011000 ,
b00011010 -
b0100 7
1L
b00011010 N
#21
0L
#22
b1011010100001111 #
b10 $
b10 %
1'
0(
b00000000000000000000000000011001 +
b00011010 ,
b00011100 -
b00011110 .
b00001111 /
b00001111 0
b0000000000011100 1
b0000000000000000 2
b0000000000000000 4
b0000010100000010 5
b0101 7
b1111 9
1L
b00011110 N
#23
0L
#24
b0000010100000010 #
b00 $
b00 %
0'
1(
b00000000000000000000000000000011 +
b00011110 ,
b00100000 -
b00000100 .
b00000010 /
b00000000 0
b0000000000000010 1
b0000000000011100 2
b0000000000000110 4
b0001000100101010 5
b0010 9
b0000000000011100 ?
1L
b00100000 N
#25
0L
#26
b0000010100000011 #
b11 %
0(
b00000000000000000000000000010011 +
b00100000 ,
b00100010 -
b00111000 .
b00000011 /
b00000011 0
b0000000000000011 1
b0000000000101010 4
b0001001000000110 5
b0011 9
1L
b00111000 N
#27
0L
#28
b0000000000000000 #
b00 %
b00000000000000000000000000000000 +
b00111000 ,
b00111010 -
b00000000 .
b00000000 /
b00000000 0
b0000000000000000 1
b0000000000000000 2
b0000000000000000 4
b0001000100101010 5
b0000 7
b0000 9
1L
b00111010 N
#29
0L
#30
b00111010 ,
b00111100 -
b00000000000000000000000000001111 J
b00000000000000000000000011111111 K
1L
b00111100 N
