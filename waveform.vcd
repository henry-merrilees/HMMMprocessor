$version Generated by VerilatedVcd $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire  1 U clk $end
  $var wire  1 V reset $end
  $scope module hmmm $end
   $var wire  1 * ALUSrcA $end
   $var wire  1 + ALUSrcB $end
   $var wire 16 # Instr [15:0] $end
   $var wire  1 ( MemAdrSrc $end
   $var wire  1 ) MemDataSrc $end
   $var wire  1 & MemWrite $end
   $var wire  2 % PcSrc [1:0] $end
   $var wire  2 $ RegSrc [1:0] $end
   $var wire  1 ' RegWrite $end
   $var wire 32 , alu_op [31:0] $end
   $var wire  1 U clk $end
   $var wire 32 - instruction_type [31:0] $end
   $var wire  1 V reset $end
   $scope module controller $end
    $var wire  1 * ALUSrcA $end
    $var wire  1 + ALUSrcB $end
    $var wire  1 ( MemAdrSrc $end
    $var wire  1 ) MemDataSrc $end
    $var wire  1 & MemWrite $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  2 $ RegSrc [1:0] $end
    $var wire  1 ' RegWrite $end
    $var wire 32 , alu_op [31:0] $end
    $var wire 16 # instr [15:0] $end
    $var wire 32 - instruction_type [31:0] $end
   $upscope $end
   $scope module datapath $end
    $var wire  1 * ALUSrcA $end
    $var wire  1 + ALUSrcB $end
    $var wire  8 1 Imm [7:0] $end
    $var wire 16 B ImmExt [15:0] $end
    $var wire 16 # Instr [15:0] $end
    $var wire  1 ( MemAdrSrc $end
    $var wire  1 ) MemDataSrc $end
    $var wire  1 & MemWrite $end
    $var wire  8 . Pc [7:0] $end
    $var wire  8 W PcNext [7:0] $end
    $var wire  8 / PcPlus2 [7:0] $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  8 0 PcTarget [7:0] $end
    $var wire  2 $ RegSrc [1:0] $end
    $var wire  1 ' RegWrite $end
    $var wire 32 , alu_op [31:0] $end
    $var wire 16 4 alu_result [15:0] $end
    $var wire 16 5 alu_src_a [15:0] $end
    $var wire 16 6 alu_src_b [15:0] $end
    $var wire  1 U clk $end
    $var wire 32 - instruction_type [31:0] $end
    $var wire  8 2 mem_data_address [7:0] $end
    $var wire 16 : mem_read_data [15:0] $end
    $var wire 16 ; mem_write_data [15:0] $end
    $var wire  4 < rX [3:0] $end
    $var wire  4 = rY [3:0] $end
    $var wire  4 > rZ [3:0] $end
    $var wire  1 V reset $end
    $var wire 16 3 result [15:0] $end
    $var wire 16 7 rf_read_data_1 [15:0] $end
    $var wire 16 8 rf_read_data_2 [15:0] $end
    $var wire 16 9 rf_read_data_3 [15:0] $end
    $var wire  1 @ sign $end
    $var wire  1 A take_jump $end
    $var wire  1 ? zero $end
    $scope module alu $end
     $var wire 32 , alu_op [31:0] $end
     $var wire 16 4 alu_result [15:0] $end
     $var wire  1 @ sign $end
     $var wire 16 5 src_a [15:0] $end
     $var wire 16 6 src_b [15:0] $end
     $var wire  1 ? zero $end
    $upscope $end
    $scope module mem $end
     $var wire  1 U clk $end
     $var wire  8 2 data_address [7:0] $end
     $var wire  8 . instruction_address [7:0] $end
     $var wire 16 # instruction_data [15:0] $end
     $var wire 16 : read_data [15:0] $end
     $var wire 16 ; write_data [15:0] $end
     $var wire  1 & write_en $end
    $upscope $end
    $scope module rf $end
     $var wire  4 < address_1 [3:0] $end
     $var wire  4 = address_2 [3:0] $end
     $var wire  4 > address_3 [3:0] $end
     $var wire  1 U clk $end
     $var wire 16 7 read_data_1 [15:0] $end
     $var wire 16 8 read_data_2 [15:0] $end
     $var wire 16 9 read_data_3 [15:0] $end
     $var wire 16 C registers[0] [15:0] $end
     $var wire 16 M registers[10] [15:0] $end
     $var wire 16 N registers[11] [15:0] $end
     $var wire 16 O registers[12] [15:0] $end
     $var wire 16 P registers[13] [15:0] $end
     $var wire 16 Q registers[14] [15:0] $end
     $var wire 16 R registers[15] [15:0] $end
     $var wire 16 D registers[1] [15:0] $end
     $var wire 16 E registers[2] [15:0] $end
     $var wire 16 F registers[3] [15:0] $end
     $var wire 16 G registers[4] [15:0] $end
     $var wire 16 H registers[5] [15:0] $end
     $var wire 16 I registers[6] [15:0] $end
     $var wire 16 J registers[7] [15:0] $end
     $var wire 16 K registers[8] [15:0] $end
     $var wire 16 L registers[9] [15:0] $end
     $var wire 16 3 write_data_1 [15:0] $end
     $var wire  1 ' write_en_1 $end
    $upscope $end
    $scope module unnamedblk1 $end
     $var wire 32 S i [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 T i [31:0] $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b0001111000000000 #
b00 $
b00 %
0&
1'
0(
0)
0*
0+
b00000000000000000000000000000000 ,
b00000000000000000000000000000100 -
b00000000 .
b00000010 /
b00000000 0
b00000000 1
b00000000 2
b0000000000000000 3
b0000000000000000 4
b0000000000000000 5
b0000000000000000 6
b0000000000000000 7
b0000000000000000 8
b0000000000000000 9
b0001111000000000 :
b0000000000000000 ;
b1110 <
b0000 =
b0000 >
1?
0@
1A
b0000000000000000 B
b0000000000000000 C
b0000000000000000 D
b0000000000000000 E
b0000000000000000 F
b0000000000000000 G
b0000000000000000 H
b0000000000000000 I
b0000000000000000 J
b0000000000000000 K
b0000000000000000 L
b0000000000000000 M
b0000000000000000 N
b0000000000000000 O
b0000000000000000 P
b0000000000000000 Q
b0000000000000000 R
b00000000000000000000000000000000 S
b00000000000000000000000000000000 T
1U
1V
b00000000 W
#1
0U
#2
b0001111100000001 #
b00000010 .
b00000100 /
b00000010 0
b00000001 1
b00000001 2
b0000000000000001 3
b0001111100000001 :
b1111 <
b0001 >
b0000000000000001 B
1U
0V
b00000100 W
#3
0U
#4
b1011000000001001 #
b10 %
0'
b00000000000000000000000000010100 -
b00000100 .
b00000110 /
b00010010 0
b00001001 1
b00001001 2
b0000000000001001 3
b0001010000010111 :
b0000 <
b1001 >
b0000000000001001 B
b0000000000000001 R
1U
b00010010 W
#5
0U
#6
b0001010000010111 #
b00 %
1'
b00000000000000000000000000000100 -
b00010010 .
b00010100 /
b00101110 0
b00010111 1
b00010111 2
b0000000000010111 3
b0000000000000000 :
b0100 <
b0001 =
b0111 >
b0000000000010111 B
1U
b00010100 W
#7
0U
#8
b0001010100010011 #
b00010100 .
b00010110 /
b00100110 0
b00010011 1
b00010011 2
b0000000000010011 3
b0000111000000010 :
b0101 <
b0011 >
b0000000000010011 B
b0000000000010111 G
1U
b00010110 W
#9
0U
#10
b0001001100101010 #
b00010110 .
b00011000 /
b01010100 0
b00101010 1
b00101010 2
b0000000000101010 3
b0000000000000000 :
b0011 <
b0010 =
b1010 >
b0000000000101010 B
b0000000000010011 H
1U
b00011000 W
#11
0U
#12
b0110001001000101 #
b11 $
b00000000000000000000000000001100 -
b00011000 .
b00011010 /
b10001010 0
b01000101 1
b01000101 2
b0000000000101010 4
b0000000000010111 5
b0000000000010011 6
b0000000000010111 8
b0000000000010011 9
b0000000000101010 ;
b0010 <
b0100 =
b0101 >
0?
b0000000001000101 B
b0000000000101010 F
1U
b00011010 W
#13
0U
#14
b1011000100000101 #
b10 $
b10 %
b00000000000000000000000000011001 -
b00011010 .
b00011100 /
b00001010 0
b00000101 1
b00000101 2
b0000000000011100 3
b0000000000010011 4
b0000000000000000 5
b0000000000000000 8
b0111001000100011 :
b0000000000010011 ;
b0001 <
b0000 =
b0000000000000101 B
b0000000000101010 E
1U
b00001010 W
#15
0U
#16
b0111001000100011 #
b11 $
b00 %
b00000000000000000000000000000001 ,
b00000000000000000000000000001110 -
b00001010 .
b00001100 /
b01000110 0
b00100011 1
b00100011 2
b0000000000000000 3
b0000000000000000 4
b0000000000101010 5
b0000000000101010 6
b0000000000101010 7
b0000000000101010 8
b0000000000101010 9
b0000000000000000 :
b0000000000000000 ;
b0010 <
b0010 =
b0011 >
1?
b0000000000100011 B
b0000000000011100 D
1U
b00001100 W
#17
0U
#18
b1100001000001000 #
b00 $
b10 %
0'
b00000000000000000000000000000000 ,
b00000000000000000000000000010101 -
b00001100 .
b00001110 /
b00010000 0
b00001000 1
b00001000 2
b0000000000001000 3
b0000000000000000 5
b0000000000000000 6
b0000000000000000 7
b0000000000000000 8
b0000000000000000 9
b0000000100000011 :
b0000 =
b1000 >
b0000000000001000 B
b0000000000000000 E
1U
b00010000 W
#19
0U
#20
b0000000100000011 #
b11 %
b00000000000000000000000000010011 -
b00010000 .
b00010010 /
b00111000 0
b00000011 1
b00000011 2
b0000000000000011 3
b0000000000101010 4
b0000000000101010 6
b0000000000011100 7
b0000000000101010 9
b0000111100000010 :
b0000000000101010 ;
b0001 <
b0011 >
0?
b0000000000000011 B
1U
b00111000 W
#21
0U
#22
b0000000000000000 #
b00 %
b00000000000000000000000000000000 -
b00111000 .
b00111010 /
b00000000 0
b00000000 1
b00000000 2
b0000000000000000 3
b0000000000000000 4
b0000000000000000 6
b0000000000000000 7
b0000000000000000 9
b0001111000000000 :
b0000000000000000 ;
b0000 <
b0000 >
1?
b0000000000000000 B
1U
b00111010 W
#23
0U
#24
b00111010 .
b00111100 /
b00000000000000000000000000001111 S
b00000000000000000000000011111111 T
1U
b00111100 W
