$version Generated by VerilatedVcd $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire  1 S clk $end
  $var wire  1 T reset $end
  $scope module hmmm $end
   $var wire  1 * ALUSrcA $end
   $var wire  1 + ALUSrcB $end
   $var wire 16 # Instr [15:0] $end
   $var wire  1 ( MemAdrSrc $end
   $var wire  1 ) MemDataSrc $end
   $var wire  1 & MemWrite $end
   $var wire  2 % PcSrc [1:0] $end
   $var wire  2 $ RegSrc [1:0] $end
   $var wire  1 ' RegWrite $end
   $var wire 32 , alu_op [31:0] $end
   $var wire  1 S clk $end
   $var wire 32 - instruction_type [31:0] $end
   $var wire  1 T reset $end
   $scope module controller $end
    $var wire  1 * ALUSrcA $end
    $var wire  1 + ALUSrcB $end
    $var wire  1 ( MemAdrSrc $end
    $var wire  1 ) MemDataSrc $end
    $var wire  1 & MemWrite $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  2 $ RegSrc [1:0] $end
    $var wire  1 ' RegWrite $end
    $var wire 32 , alu_op [31:0] $end
    $var wire 16 # instr [15:0] $end
    $var wire 32 - instruction_type [31:0] $end
   $upscope $end
   $scope module datapath $end
    $var wire  1 * ALUSrcA $end
    $var wire  1 + ALUSrcB $end
    $var wire  8 1 Imm [7:0] $end
    $var wire 16 # Instr [15:0] $end
    $var wire  1 ( MemAdrSrc $end
    $var wire  1 ) MemDataSrc $end
    $var wire  1 & MemWrite $end
    $var wire  8 . Pc [7:0] $end
    $var wire  8 U PcNext [7:0] $end
    $var wire  8 / PcPlus2 [7:0] $end
    $var wire  2 % PcSrc [1:0] $end
    $var wire  8 0 PcTarget [7:0] $end
    $var wire  2 $ RegSrc [1:0] $end
    $var wire  1 ' RegWrite $end
    $var wire 32 , alu_op [31:0] $end
    $var wire 16 4 alu_result [15:0] $end
    $var wire 16 5 alu_src_a [15:0] $end
    $var wire 16 6 alu_src_b [15:0] $end
    $var wire  1 S clk $end
    $var wire 32 - instruction_type [31:0] $end
    $var wire  8 2 mem_data_address [7:0] $end
    $var wire 16 : mem_read_data [15:0] $end
    $var wire 16 ; mem_write_data [15:0] $end
    $var wire  4 < rX [3:0] $end
    $var wire  4 = rY [3:0] $end
    $var wire  4 > rZ [3:0] $end
    $var wire  1 T reset $end
    $var wire 16 3 result [15:0] $end
    $var wire 16 7 rf_read_data_1 [15:0] $end
    $var wire 16 8 rf_read_data_2 [15:0] $end
    $var wire 16 9 rf_read_data_3 [15:0] $end
    $var wire  1 @ sign $end
    $var wire  1 ? zero $end
    $scope module alu $end
     $var wire 32 , alu_op [31:0] $end
     $var wire 16 4 alu_result [15:0] $end
     $var wire  1 @ sign $end
     $var wire 16 5 src_a [15:0] $end
     $var wire 16 6 src_b [15:0] $end
     $var wire  1 ? zero $end
    $upscope $end
    $scope module mem $end
     $var wire  1 S clk $end
     $var wire  8 2 data_address [7:0] $end
     $var wire  8 . instruction_address [7:0] $end
     $var wire 16 # instruction_data [15:0] $end
     $var wire 16 : read_data [15:0] $end
     $var wire 16 ; write_data [15:0] $end
     $var wire  1 & write_en $end
    $upscope $end
    $scope module rf $end
     $var wire  4 < address_1 [3:0] $end
     $var wire  4 = address_2 [3:0] $end
     $var wire  4 > address_3 [3:0] $end
     $var wire  1 S clk $end
     $var wire 16 7 read_data_1 [15:0] $end
     $var wire 16 8 read_data_2 [15:0] $end
     $var wire 16 9 read_data_3 [15:0] $end
     $var wire 16 A registers[0] [15:0] $end
     $var wire 16 K registers[10] [15:0] $end
     $var wire 16 L registers[11] [15:0] $end
     $var wire 16 M registers[12] [15:0] $end
     $var wire 16 N registers[13] [15:0] $end
     $var wire 16 O registers[14] [15:0] $end
     $var wire 16 P registers[15] [15:0] $end
     $var wire 16 B registers[1] [15:0] $end
     $var wire 16 C registers[2] [15:0] $end
     $var wire 16 D registers[3] [15:0] $end
     $var wire 16 E registers[4] [15:0] $end
     $var wire 16 F registers[5] [15:0] $end
     $var wire 16 G registers[6] [15:0] $end
     $var wire 16 H registers[7] [15:0] $end
     $var wire 16 I registers[8] [15:0] $end
     $var wire 16 J registers[9] [15:0] $end
     $var wire 16 3 write_data_1 [15:0] $end
     $var wire  1 ' write_en_1 $end
    $upscope $end
    $scope module unnamedblk1 $end
     $var wire 32 Q i [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 R i [31:0] $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b0001000100000001 #
b00 $
b00 %
0&
1'
0(
0)
0*
0+
b00000000000000000000000000000000 ,
b00000000000000000000000000000100 -
b00000000 .
b00000010 /
b00000010 0
b00000001 1
b00000001 2
b0000000000000001 3
b0000000000000000 4
b0000000000000000 5
b0000000000000000 6
b0000000000000000 7
b0000000000000000 8
b0000000000000000 9
b0001001000000010 :
b0000000000000000 ;
b0001 <
b0000 =
b0001 >
1?
0@
b0000000000000000 A
b0000000000000000 B
b0000000000000000 C
b0000000000000000 D
b0000000000000000 E
b0000000000000000 F
b0000000000000000 G
b0000000000000000 H
b0000000000000000 I
b0000000000000000 J
b0000000000000000 K
b0000000000000000 L
b0000000000000000 M
b0000000000000000 N
b0000000000000000 O
b0000000000000000 P
b00000000000000000000000000000000 Q
b00000000000000000000000000000000 R
1S
1T
b00000000 U
#1
0S
#2
b0001001000000010 #
b00000010 .
b00000100 /
b00000100 0
b00000010 1
b00000010 2
b0000000000000010 3
b0110001100100001 :
b0010 <
b0010 >
b0000000000000001 B
1S
0T
b00000100 U
#3
0S
#4
b0110001100100001 #
b11 $
b00000000000000000000000000001100 -
b00000100 .
b00000110 /
b01000010 0
b00100001 1
b00100001 2
b0000000000000001 3
b0000000000000001 4
b0000000000000001 6
b0000000000000010 8
b0000000000000001 9
b0000000000000000 :
b0000000000000001 ;
b0011 <
b0010 =
b0001 >
0?
b0000000000000010 C
1S
b00000110 U
#5
0S
#6
b1000010000110010 #
b00000000000000000000000000000010 ,
b00000000000000000000000000010000 -
b00000110 .
b00001000 /
b01100100 0
b00110010 1
b00110010 2
b0000000000000000 3
b0000000000000000 4
b0000000000000010 6
b0000000000000001 8
b0000000000000010 9
b0000000000000000 ;
b0100 <
b0011 =
b0010 >
1?
b0000000000000001 D
1S
b00001000 U
#7
0S
#8
b0001010100001000 #
b00 $
b00000000000000000000000000000000 ,
b00000000000000000000000000000100 -
b00001000 .
b00001010 /
b00010000 0
b00001000 1
b00001000 2
b0000000000001000 3
b0000000000000000 6
b0000000000000000 8
b0000000000000000 9
b0101 <
b0000 =
b1000 >
1S
b00001010 U
#9
0S
#10
b1001010101010010 #
b11 $
b00000000000000000000000000000011 ,
b00000000000000000000000000010001 -
b00001010 .
b00001100 /
b10100100 0
b01010010 1
b01010010 2
b0000000000000100 3
b0000000000000100 4
b0000000000001000 5
b0000000000000010 6
b0000000000001000 7
b0000000000001000 8
b0000000000000010 9
b0000000000000100 ;
b0101 =
b0010 >
0?
b0000000000001000 F
1S
b00001100 U
#11
0S
#12
b1010010101010011 #
b00000000000000000000000000000100 ,
b00000000000000000000000000010010 -
b00001100 .
b00001110 /
b10100110 0
b01010011 1
b01010011 2
b0000000000000000 3
b0000000000000000 4
b0000000000000100 5
b0000000000000001 6
b0000000000000100 7
b0000000000000100 8
b0000000000000001 9
b0000000000000000 ;
b0011 >
1?
b0000000000000100 F
1S
b00001110 U
#13
0S
#14
b0101010100001010 #
1*
1+
b00000000000000000000000000000000 ,
b00000000000000000000000000001011 -
b00001110 .
b00010000 /
b00010100 0
b00001010 1
b00001010 2
b0000000000001010 3
b0000000000001010 4
b0000000000000000 5
b0000000000001010 6
b0000000000000000 7
b0000000000000000 8
b0000000000000000 9
b0000000000001010 ;
b0000 =
b1010 >
0?
b0000000000000000 F
1S
b00010000 U
#15
0S
#16
b0000000000000000 #
b00 $
0'
0*
0+
b00000000000000000000000000000000 -
b00010000 .
b00010010 /
b00000000 0
b00000000 1
b00000000 2
b0000000000000000 3
b0000000000000000 4
b0000000000000000 6
b0001000100000001 :
b0000000000000000 ;
b0000 <
b0000 >
1?
b0000000000001010 F
1S
b00010010 U
#17
0S
#18
b00010010 .
b00010100 /
b00000000000000000000000000001111 Q
b00000000000000000000000011111111 R
1S
b00010100 U
